//! Sine/cosine live-plot running in the browser (or as a native binary).
//!
//! Build & serve for the web:
//! ```bash
//! cd examples/web_sine_cosine
//! trunk serve
//! ```
//!
//! Run natively:
//! ```bash
//! cd examples/web_sine_cosine
//! cargo run
//! ```

use egui_plot::{Legend, Line, Plot, PlotPoints};
use web_time::Instant;

const FREQ_HZ: f64 = 3.0; // signal frequency
const SAMPLE_RATE: f64 = 200.0; // samples per second fed to the buffer
const WINDOW_SECS: f64 = 5.0; // rolling display window

// ---------------------------------------------------------------------------
// Application state
// ---------------------------------------------------------------------------

struct SineCosineApp {
    start: Instant,
    sine_points: Vec<[f64; 2]>,
    cos_points: Vec<[f64; 2]>,
    last_t: f64,
}

impl SineCosineApp {
    fn new(_cc: &eframe::CreationContext<'_>) -> Self {
        Self {
            start: Instant::now(),
            sine_points: Vec::new(),
            cos_points: Vec::new(),
            last_t: -1.0 / SAMPLE_RATE,
        }
    }

    /// Advance the sample buffer up to the current wall-clock time.
    fn advance_buffer(&mut self) {
        let now = self.start.elapsed().as_secs_f64();
        let dt = 1.0 / SAMPLE_RATE;
        let mut t = self.last_t + dt;
        while t <= now {
            let s = (2.0 * std::f64::consts::PI * FREQ_HZ * t).sin();
            let c = (2.0 * std::f64::consts::PI * FREQ_HZ * t).cos();
            self.sine_points.push([t, s]);
            self.cos_points.push([t, c]);
            t += dt;
        }
        self.last_t = now;

        // Trim old samples outside the rolling window.
        let cutoff = now - WINDOW_SECS;
        self.sine_points.retain(|p| p[0] >= cutoff);
        self.cos_points.retain(|p| p[0] >= cutoff);
    }
}

// ---------------------------------------------------------------------------
// egui/eframe App implementation
// ---------------------------------------------------------------------------

impl eframe::App for SineCosineApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        self.advance_buffer();

        // Request continuous repaints so the plot keeps moving.
        ctx.request_repaint();

        egui::CentralPanel::default().show(ctx, |ui| {
            ui.heading("Sine & Cosine – Live Web Demo");
            ui.separator();

            let available = ui.available_size();
            let plot = Plot::new("sine_cosine")
                .height(available.y - 8.0)
                .legend(Legend::default())
                .x_axis_label("time (s)")
                .y_axis_label("amplitude");

            plot.show(ui, |plot_ui| {
                plot_ui.line(Line::new(
                    "sine",
                    PlotPoints::from(self.sine_points.clone()),
                ));
                plot_ui.line(Line::new(
                    "cosine",
                    PlotPoints::from(self.cos_points.clone()),
                ));
            });
        });
    }
}

// ---------------------------------------------------------------------------
// Entry points
// ---------------------------------------------------------------------------

#[cfg(not(target_arch = "wasm32"))]
fn main() -> eframe::Result<()> {
    env_logger::init();
    eframe::run_native(
        "Sine Cosine Web",
        eframe::NativeOptions::default(),
        Box::new(|cc| Ok(Box::new(SineCosineApp::new(cc)))),
    )
}

/// WebAssembly entry point – invoked by the JS glue generated by `trunk`.
#[cfg(target_arch = "wasm32")]
fn main() {
    // Redirect `log` records to the browser console.
    eframe::WebLogger::init(log::LevelFilter::Debug).ok();

    let web_options = eframe::WebOptions::default();

    wasm_bindgen_futures::spawn_local(async {
        use wasm_bindgen::JsCast as _;
        use web_sys::HtmlCanvasElement;

        let canvas: HtmlCanvasElement = web_sys::window()
            .expect("no global `window`")
            .document()
            .expect("should have a document")
            .get_element_by_id("the_canvas_id")
            .expect("document should have element #the_canvas_id")
            .dyn_into::<HtmlCanvasElement>()
            .expect("#the_canvas_id should be a <canvas>");

        eframe::WebRunner::new()
            .start(
                canvas,
                web_options,
                Box::new(|cc| Ok(Box::new(SineCosineApp::new(cc)))),
            )
            .await
            .expect("failed to start eframe");
    });
}
